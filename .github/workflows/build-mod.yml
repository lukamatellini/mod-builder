name: Build Minecraft Mod

on:
  workflow_dispatch:
    inputs:
      mod_id:
        description: "Mod UUID from database"
        required: true
      mod_name:
        description: "Human-readable mod name"
        required: true
      loader:
        description: "Mod loader (fabric or forge)"
        required: true
        default: "fabric"
      mc_version:
        description: "Minecraft version (must be 1.21.x)"
        required: true
        default: "1.21.11"
      mod_files:
        description: "Base64-encoded JSON of mod files"
        required: true
      webhook_url:
        description: "URL to call when build completes"
        required: true
      webhook_secret:
        description: "Secret for webhook authentication"
        required: true

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 25

    steps:
      - name: Guardrails (Fabric + MC 1.21.x only)
        run: |
          set -e
          if [ "${{ github.event.inputs.loader }}" != "fabric" ]; then
            echo "ERROR: This workflow supports Fabric only."
            exit 1
          fi

          MC="${{ github.event.inputs.mc_version }}"
          case "$MC" in
            1.21.*) echo "OK: MC version allowed: $MC" ;;
            *) echo "ERROR: Unsupported mc_version: $MC (allow only 1.21.x)"; exit 1 ;;
          esac

      - name: Set up Node.js (for unpacking mod_files)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Create mod project from mod_files
        run: |
          set -e
          mkdir -p mod-project
          cd mod-project

          echo '${{ github.event.inputs.mod_files }}' | base64 -d > files.json

          node << 'EOF'
          const fs = require('fs');
          const path = require('path');

          const files = JSON.parse(fs.readFileSync('files.json', 'utf8'));
          for (const [filePath, content] of Object.entries(files)) {
            const fullPath = path.join('.', filePath);
            fs.mkdirSync(path.dirname(fullPath), { recursive: true });
            fs.writeFileSync(fullPath, content);
          }
          console.log("Unpacked files:", Object.keys(files).length);
          EOF

      - name: Read modid from fabric.mod.json + check MC range declaration
        id: modmeta
        working-directory: mod-project
        run: |
          set -e
          node << 'EOF'
          const fs = require('fs');
          const p = 'src/main/resources/fabric.mod.json';
          if (!fs.existsSync(p)) throw new Error(`Missing ${p}`);
          const meta = JSON.parse(fs.readFileSync(p,'utf8'));
          if (!meta.id) throw new Error("fabric.mod.json missing 'id'");
          if (!meta.depends || !meta.depends.minecraft) throw new Error("fabric.mod.json missing depends.minecraft");

          // Require: >=1.21 <1.22 (your stated goal: all 1.21.*)
          const mc = String(meta.depends.minecraft).replace(/\s+/g,'');
          if (!(mc.includes(">=1.21") && mc.includes("<1.22"))) {
            throw new Error(`depends.minecraft must include ">=1.21 <1.22". Found: ${meta.depends.minecraft}`);
          }

          console.log(meta.id);
          EOF > /tmp/modid.txt

          echo "modid=$(cat /tmp/modid.txt)" >> $GITHUB_OUTPUT
          echo "Detected modid: $(cat /tmp/modid.txt)"

      - name: Set up Java 21 (Minecraft 1.21.x)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3
        with:
          gradle-version: "8.4"

      - name: Build with Gradle (prefer wrapper)
        id: build
        working-directory: mod-project
        run: |
          set -e

          if [ -f "./gradlew" ]; then
            chmod +x ./gradlew
            ./gradlew clean build --no-daemon --info
          else
            gradle clean build --no-daemon --info
          fi

          echo "==== build/libs contents ===="
          ls -lah build/libs || true

          # Pick the largest distributable jar (exclude sources/javadoc/dev)
          JAR_FILE=$(ls -1S build/libs/*.jar \
            | grep -vE '(sources|javadoc|dev)\.jar$' \
            | head -n 1)

          if [ -z "$JAR_FILE" ]; then
            echo "ERROR: No distributable jar found in build/libs"
            exit 1
          fi

          echo "jar_file=$JAR_FILE" >> $GITHUB_OUTPUT
          echo "jar_name=$(basename $JAR_FILE)" >> $GITHUB_OUTPUT
          echo "Built JAR: $JAR_FILE"

      - name: Validate jar (base + conditional features)
        working-directory: mod-project
        run: |
          set -e
          JAR="${{ steps.build.outputs.jar_file }}"
          MODID="${{ steps.modmeta.outputs.modid }}"

          echo "Validating jar: $JAR"

          # Base: must be a real Fabric mod jar
          unzip -l "$JAR" | grep -q "fabric.mod.json" || (echo "ERROR: Missing fabric.mod.json inside jar" && exit 1)
          unzip -l "$JAR" | grep -qE "\.class$" || (echo "ERROR: No compiled .class files found inside jar" && exit 1)

          # Conditional: quests (only enforce if folder exists)
          if unzip -l "$JAR" | grep -q "data/$MODID/quests/"; then
            unzip -l "$JAR" | grep -qE "data/$MODID/quests/.+\.json$" || (echo "ERROR: quests folder exists but no quest .json files" && exit 1)
          else
            echo "INFO: No quests folder (ok if user didn’t request quests)."
          fi

          # Conditional: dialogue (only enforce if folder exists)
          if unzip -l "$JAR" | grep -q "data/$MODID/dialogue/"; then
            unzip -l "$JAR" | grep -qE "data/$MODID/dialogue/.+\.json$" || (echo "ERROR: dialogue folder exists but no dialogue .json files" && exit 1)
          else
            echo "INFO: No dialogue folder (ok if user didn’t request NPC dialogue)."
          fi

          # Conditional: worldgen (structures/biomes/dimensions)
          if unzip -l "$JAR" | grep -q "data/$MODID/worldgen/"; then
            unzip -l "$JAR" | grep -qE "data/$MODID/worldgen/.+\.json$" || (echo "ERROR: worldgen folder exists but no worldgen .json files" && exit 1)
          else
            echo "INFO: No worldgen folder (ok if user didn’t request structures/biomes/dimensions)."
          fi

          # Nice-to-have warnings
          unzip -l "$JAR" | grep -q "assets/$MODID/lang/" || echo "WARN: Missing assets/$MODID/lang/"
          unzip -l "$JAR" | grep -q "assets/$MODID/textures/" || echo "WARN: Missing assets/$MODID/textures/ (ok if no custom visuals requested)"
          unzip -l "$JAR" | grep -q "assets/$MODID/sounds.json" || echo "WARN: Missing assets/$MODID/sounds.json (ok if only vanilla sounds used)"

          echo "Validation passed."

      - name: Upload to R2
        id: upload
        env:
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
          R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
          R2_PUBLIC_URL: ${{ secrets.R2_PUBLIC_URL }}
        run: |
          set -e
          cd mod-project
          JAR_FILE="${{ steps.build.outputs.jar_file }}"
          JAR_NAME="${{ steps.build.outputs.jar_name }}"
          MOD_ID="${{ github.event.inputs.mod_id }}"

          pip install awscli

          aws configure set aws_access_key_id "$R2_ACCESS_KEY_ID"
          aws configure set aws_secret_access_key "$R2_SECRET_ACCESS_KEY"
          aws configure set region auto

          TIMESTAMP=$(date +%s)
          KEY="compiled-mods/${MOD_ID}/${TIMESTAMP}_${JAR_NAME}"

          aws s3 cp "$JAR_FILE" "s3://${R2_BUCKET_NAME}/${KEY}" \
            --endpoint-url "https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com" \
            --content-type "application/java-archive"

          if [ -n "$R2_PUBLIC_URL" ]; then
            PUBLIC_URL="${R2_PUBLIC_URL}/${KEY}"
          else
            PUBLIC_URL="https://${R2_BUCKET_NAME}.r2.dev/${KEY}"
          fi

          echo "jar_url=$PUBLIC_URL" >> $GITHUB_OUTPUT
          echo "Uploaded to: $PUBLIC_URL"

      - name: Notify webhook on success
        if: success()
        env:
          WEBHOOK_URL: ${{ github.event.inputs.webhook_url }}
          WEBHOOK_SECRET: ${{ github.event.inputs.webhook_secret }}
        run: |
          set -e
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "x-webhook-secret: $WEBHOOK_SECRET" \
            -d "{\"modId\":\"${{ github.event.inputs.mod_id }}\",\"status\":\"success\",\"compiledJarUrl\":\"${{ steps.upload.outputs.jar_url }}\"}"

      - name: Notify webhook on failure
        if: failure()
        env:
          WEBHOOK_URL: ${{ github.event.inputs.webhook_url }}
          WEBHOOK_SECRET: ${{ github.event.inputs.webhook_secret }}
        run: |
          set -e
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "x-webhook-secret: $WEBHOOK_SECRET" \
            -d "{\"modId\":\"${{ github.event.inputs.mod_id }}\",\"status\":\"failed\",\"error\":\"Build failed - check GitHub Actions logs\"}"




