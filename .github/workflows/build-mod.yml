name: Build Minecraft Mod (Main-Controlled)

on:
  workflow_dispatch:
    inputs:
      build_ref:
        description: "Branch to build (e.g. build/<id>/<timestamp>)"
        required: true
        type: string

jobs:
  build:
    runs-on: ubuntu-22.04
    timeout-minutes: 45

    steps:
      # ----------------------------
      # 1) Checkout generated mod project
      # ----------------------------
      - name: Checkout generated mod project
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.build_ref }}
          fetch-depth: 1

      # ----------------------------
      # 2) Setup Node (JSON parsing)
      # ----------------------------
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      # ----------------------------
      # 3) Ensure tools are available (unzip/file/pip/jq)
      # ----------------------------
      - name: Ensure unzip + file + jq are available
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y unzip file python3-pip jq

      # ----------------------------
      # 4) Read build-config.json (includes modId + webhookSecret)
      #    HARD LOCK: enforce mcVersion === 1.21.1 and loader === fabric
      # ----------------------------
      - name: Read build-config.json
        id: buildconfig
        run: |
          set -e
          node -e "
            const fs = require('fs');
            const path = 'build-config.json';
            if (!fs.existsSync(path)) throw new Error('Missing build-config.json');
            const cfg = JSON.parse(fs.readFileSync(path, 'utf8'));
            if (!cfg.modId) throw new Error('build-config.json missing modId (DB UUID)');
            if (!cfg.webhookUrl) throw new Error('build-config.json missing webhookUrl');
            if (!cfg.webhookSecret) throw new Error('build-config.json missing webhookSecret');
            if (!cfg.loader) throw new Error('build-config.json missing loader');
            if (!cfg.mcVersion) throw new Error('build-config.json missing mcVersion');

            const mc = String(cfg.mcVersion).trim();
            const loader = String(cfg.loader).trim();
            if (loader !== 'fabric') throw new Error('Only fabric loader is supported (got: ' + loader + ')');
            if (mc !== '1.21.1') throw new Error('Only Minecraft 1.21.1 is supported (got: ' + mc + ')');

            const url = String(cfg.webhookUrl).trim();
            if (!/^https?:\\/\\//.test(url)) throw new Error('webhookUrl must start with http:// or https://');

            const modUuid = String(cfg.modId).trim();
            const uuidRe = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;
            if (!uuidRe.test(modUuid)) throw new Error('modId is not a valid UUID: ' + modUuid);

            console.log('::add-mask::' + String(cfg.webhookSecret).trim());
            const out = process.env.GITHUB_OUTPUT;
            fs.appendFileSync(out, 'modUuid=' + modUuid + '\\n');
            fs.appendFileSync(out, 'webhookUrl=' + url + '\\n');
            fs.appendFileSync(out, 'webhookSecret=' + String(cfg.webhookSecret).trim() + '\\n');
            fs.appendFileSync(out, 'loader=' + loader + '\\n');
            fs.appendFileSync(out, 'mcVersion=' + mc + '\\n');
            fs.appendFileSync(out, 'modName=' + String(cfg.modName || 'Minecraft Mod').trim() + '\\n');
          "

      # ----------------------------
      # 5) STRICT GUARDRAILS - HARD LOCK (NO WILDCARDS)
      # ----------------------------
      - name: Guardrails - Hard lock Minecraft 1.21.1
        id: guardrails
        run: |
          set -e
          LOADER="${{ steps.buildconfig.outputs.loader }}"
          MC_VERSION="${{ steps.buildconfig.outputs.mcVersion }}"
          if [ "$LOADER" != "fabric" ]; then
            echo "ERROR: loader must be 'fabric', got '$LOADER'"
            exit 1
          fi
          if [ "$MC_VERSION" != "1.21.1" ]; then
            echo "============================================"
            echo "ERROR: Only Minecraft 1.21.1 is supported"
            echo "Got: $MC_VERSION"
            echo "============================================"
            exit 1
          fi
          GRADLE_VER="8.10.2"
          LOOM_VER="1.8.12"
          YARN_VER="1.21.1+build.3"
          LOADER_VER="0.16.9"
          FABRIC_API_VER="0.116.7+1.21.1"
          echo "OK: Minecraft $MC_VERSION is allowed (hard lock)"
          echo "gradle_version=$GRADLE_VER" >> "$GITHUB_OUTPUT"
          echo "loom_version=$LOOM_VER" >> "$GITHUB_OUTPUT"
          echo "yarn_version=$YARN_VER" >> "$GITHUB_OUTPUT"
          echo "loader_version=$LOADER_VER" >> "$GITHUB_OUTPUT"
          echo "fabric_api_version=$FABRIC_API_VER" >> "$GITHUB_OUTPUT"

      # ----------------------------
      # 6) Validate fabric.mod.json (HARD LOCK depends.minecraft)
      # ----------------------------
      - name: Validate fabric.mod.json
        id: modmeta
        run: |
          set -e
          node -e "
            const fs = require('fs');
            const p = 'src/main/resources/fabric.mod.json';
            if (!fs.existsSync(p)) throw new Error('Missing ' + p);
            const meta = JSON.parse(fs.readFileSync(p, 'utf8'));
            if (!meta.id) throw new Error('fabric.mod.json missing id');
            if (!meta.depends || !meta.depends.minecraft) throw new Error('fabric.mod.json missing depends.minecraft');
            const mc = String(meta.depends.minecraft).trim();
            if (mc !== '1.21.1') throw new Error('fabric.mod.json depends.minecraft must be exactly 1.21.1 (got: ' + mc + ')');
            const out = process.env.GITHUB_OUTPUT;
            fs.appendFileSync(out, 'modid=' + meta.id + '\\n');
          "

      # ----------------------------
      # 6b) Verify build-plan.json exists (early sanity check)
      # ----------------------------
      - name: Verify build-plan.json exists
        run: |
          set -e
          if [ ! -f "src/main/resources/build-plan.json" ]; then
            echo "ERROR: build-plan.json not found in source tree"
            echo "This indicates a template engine failure - the mod cannot be built"
            exit 1
          fi
          echo "OK: build-plan.json found"

      # ----------------------------
      # 6c) AUDIT FILES GATE (CRITICAL - HARD GATE)
      # ----------------------------
      - name: Verify audit + QA files exist (HARD GATE)
        run: |
          set -e
          AUDIT_PATH="src/main/resources/FEATURE_AUDIT.json"
          QA_PATH="src/main/resources/QA_TEST_PLAN.md"
          echo "=== AUDIT FILES GATE ==="
          echo "Required path: $AUDIT_PATH"
          echo "Required path: $QA_PATH"
          echo ""
          if [ ! -f "$AUDIT_PATH" ]; then
            echo "============================================"
            echo "ERROR: FEATURE_AUDIT.json NOT FOUND"
            echo "Expected: $AUDIT_PATH"
            ls -lah src/main/resources/ 2>/dev/null || echo "src/main/resources/ not found"
            ls -lah docs/ 2>/dev/null || echo "docs/ not found"
            echo "============================================"
            exit 1
          fi
          echo "Validating FEATURE_AUDIT.json schema..."
          node -e "
            const fs = require('fs');
            const audit = JSON.parse(fs.readFileSync('$AUDIT_PATH', 'utf8'));
            const requiredFields = ['modId', 'timestamp'];
            const missing = requiredFields.filter(f => !audit[f]);
            if (missing.length > 0) {
              console.error('ERROR: FEATURE_AUDIT.json missing required fields:', missing.join(', '));
              process.exit(1);
            }
            console.log('OK: FEATURE_AUDIT.json schema valid');
            console.log('  modId:', audit.modId);
            console.log('  schemaVersion:', audit.schemaVersion || 'not set');
            console.log('  overallStatus:', audit.summary?.overallStatus || 'unknown');
          "
          if [ ! -f "$QA_PATH" ]; then
            echo "WARNING: QA_TEST_PLAN.md not found at $QA_PATH"
          else
            echo "OK: QA_TEST_PLAN.md found"
          fi
          echo "=== AUDIT FILES GATE PASSED ==="

      # ----------------------------
      # 6d) Verify source files exist
      # ----------------------------
      - name: Verify source files exist
        env:
          MODID: ${{ steps.modmeta.outputs.modid }}
        run: |
          set -e
          MAIN_CLASS=$(find src/main/java -name "*.java" -type f | head -1)
          if [ -z "$MAIN_CLASS" ]; then
            echo "ERROR: No Java source files found"
            exit 1
          fi
          echo "OK: Found source files"
          if [ ! -d "src/main/resources/assets/$MODID" ]; then
            echo "ERROR: Missing assets directory for mod $MODID"
            exit 1
          fi
          echo "OK: Assets directory found"
          if [ ! -d "src/main/resources/data/$MODID" ]; then
            echo "ERROR: Missing data directory for mod $MODID"
            exit 1
          fi
          echo "OK: Data directory found"

      # ----------------------------
      # 7) TOOLCHAIN CONSISTENCY VALIDATION (hard gate)
      # ----------------------------
      - name: Validate toolchain consistency
        env:
          MC_VERSION: ${{ steps.buildconfig.outputs.mcVersion }}
          EXPECTED_GRADLE: ${{ steps.guardrails.outputs.gradle_version }}
          EXPECTED_LOOM: ${{ steps.guardrails.outputs.loom_version }}
          EXPECTED_YARN: ${{ steps.guardrails.outputs.yarn_version }}
          EXPECTED_LOADER: ${{ steps.guardrails.outputs.loader_version }}
          EXPECTED_FABRIC_API: ${{ steps.guardrails.outputs.fabric_api_version }}
        run: |
          set -e
          echo "=== Validating toolchain for MC $MC_VERSION ==="
          ERRORS=0
          if [ -f gradle.properties ]; then
            ACTUAL_MC=$(grep "^minecraft_version=" gradle.properties | cut -d'=' -f2 | tr -d ' \r')
            ACTUAL_YARN=$(grep "^yarn_mappings=" gradle.properties | cut -d'=' -f2 | tr -d ' \r')
            ACTUAL_LOADER=$(grep "^loader_version=" gradle.properties | cut -d'=' -f2 | tr -d ' \r')
            ACTUAL_FABRIC=$(grep "^fabric_version=" gradle.properties | cut -d'=' -f2 | tr -d ' \r')
            echo "minecraft_version: $ACTUAL_MC (expected: $MC_VERSION)"
            [ "$ACTUAL_MC" = "$MC_VERSION" ] || (echo "ERROR: minecraft_version mismatch" && ERRORS=$((ERRORS+1)))
            echo "yarn_mappings:     $ACTUAL_YARN (expected: $EXPECTED_YARN)"
            [ "$ACTUAL_YARN" = "$EXPECTED_YARN" ] || (echo "ERROR: yarn_mappings mismatch" && ERRORS=$((ERRORS+1)))
            echo "loader_version:   $ACTUAL_LOADER (expected: $EXPECTED_LOADER)"
            [ "$ACTUAL_LOADER" = "$EXPECTED_LOADER" ] || (echo "ERROR: loader_version mismatch" && ERRORS=$((ERRORS+1)))
            echo "fabric_version:   $ACTUAL_FABRIC (expected: $EXPECTED_FABRIC_API)"
            [ "$ACTUAL_FABRIC" = "$EXPECTED_FABRIC_API" ] || (echo "ERROR: fabric_version mismatch" && ERRORS=$((ERRORS+1)))
          else
            echo "ERROR: gradle.properties not found"
            ERRORS=$((ERRORS+1))
          fi

          GRADLE_FILE=""
          if [ -f build.gradle ]; then GRADLE_FILE="build.gradle"; fi
          if [ -f build.gradle.kts ]; then GRADLE_FILE="build.gradle.kts"; fi
          if [ -n "$GRADLE_FILE" ]; then
            echo "Checking $GRADLE_FILE for Loom version..."
            ACTUAL_LOOM=$(grep -oP "fabric-loom['\"]?\s+version\s+['\"]?\K[0-9.]+" "$GRADLE_FILE" 2>/dev/null || \
                          grep -oP "id\s+['\"]fabric-loom['\"]\s+version\s+['\"]?\K[0-9.]+" "$GRADLE_FILE" 2>/dev/null || \
                          grep -oP "id\(\"fabric-loom\"\)\s+version\s+\"\K[0-9.]+" "$GRADLE_FILE" 2>/dev/null || \
                          echo "")
            if [ -z "$ACTUAL_LOOM" ]; then
              echo "WARNING: Could not extract Loom version from $GRADLE_FILE (skipping hard fail)"
            else
              echo "loom version:      $ACTUAL_LOOM (expected: $EXPECTED_LOOM)"
              [ "$ACTUAL_LOOM" = "$EXPECTED_LOOM" ] || (echo "ERROR: loom version mismatch" && ERRORS=$((ERRORS+1)))
            fi
          else
            echo "ERROR: build.gradle(.kts) not found"
            ERRORS=$((ERRORS+1))
          fi

          if [ -f gradle/wrapper/gradle-wrapper.properties ]; then
            ACTUAL_GRADLE=$(grep -oP "gradle-\K[0-9.]+" gradle/wrapper/gradle-wrapper.properties | head -1)
            echo "wrapper gradle:   $ACTUAL_GRADLE (expected: $EXPECTED_GRADLE)"
            [ "$ACTUAL_GRADLE" = "$EXPECTED_GRADLE" ] || (echo "ERROR: gradle version mismatch" && ERRORS=$((ERRORS+1)))
          else
            echo "NOTE: gradle-wrapper.properties not found yet (will be generated)"
          fi

          if [ $ERRORS -gt 0 ]; then
            echo "============================================"
            echo "ERROR: Toolchain validation FAILED ($ERRORS)"
            echo "============================================"
            exit 1
          fi
          echo "=== Toolchain validation PASSED ==="

      # ----------------------------
      # 8) Java 21 (Required for Minecraft 1.21+)
      # ----------------------------
      - name: Set up Java 21 (Required for Minecraft 1.21+)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"

      # ----------------------------
      # 9) Setup Gradle (dynamic version from guardrails)
      # ----------------------------
      - name: Setup Gradle (dynamic version)
        uses: gradle/actions/setup-gradle@v3
        with:
          gradle-version: ${{ steps.guardrails.outputs.gradle_version }}

      # ----------------------------
      # 10) Ensure Gradle wrapper exists with correct version
      # ----------------------------
      - name: Ensure Gradle wrapper exists
        env:
          GRADLE_VERSION: ${{ steps.guardrails.outputs.gradle_version }}
        run: |
          set -e
          echo "Required Gradle version: $GRADLE_VERSION"
          if [ ! -f "./gradlew" ]; then
            echo "No ./gradlew found — generating wrapper with Gradle $GRADLE_VERSION"
            gradle wrapper --gradle-version "$GRADLE_VERSION"
          else
            if [ -f gradle/wrapper/gradle-wrapper.properties ]; then
              CURRENT=$(grep -oP "gradle-\K[0-9.]+" gradle/wrapper/gradle-wrapper.properties | head -1)
              if [ "$CURRENT" != "$GRADLE_VERSION" ]; then
                echo "Wrapper version mismatch: $CURRENT != $GRADLE_VERSION"
                echo "Regenerating wrapper with correct version..."
                gradle wrapper --gradle-version "$GRADLE_VERSION"
              else
                echo "Wrapper already uses correct Gradle version: $CURRENT"
              fi
            fi
          fi
          chmod +x ./gradlew
          ls -lah gradle/wrapper || true

      # ----------------------------
      # 11) Wrapper sanity check
      # ----------------------------
      - name: Validate Gradle wrapper jar
        run: |
          set -e
          test -f ./gradlew || (echo "ERROR: gradlew missing" && exit 1)
          test -f gradle/wrapper/gradle-wrapper.properties || (echo "ERROR: gradle-wrapper.properties missing" && exit 1)
          test -f gradle/wrapper/gradle-wrapper.jar || (echo "ERROR: gradle-wrapper.jar missing" && exit 1)
          unzip -l gradle/wrapper/gradle-wrapper.jar | grep -q "org/gradle/wrapper/GradleWrapperMain.class" \
            && echo "OK: GradleWrapperMain present" \
            || (echo "ERROR: GradleWrapperMain NOT in jar" && exit 1)

      # ----------------------------
      # 12) Build mod
      # ----------------------------
      - name: Build mod with Gradle
        id: build
        run: |
          set -e
          ./gradlew --version
          ./gradlew clean build remapJar --no-daemon --info 2>&1 | tee build.log
          ls -lah build/libs || true
          JAR_FILE=$(ls -1S build/libs/*.jar 2>/dev/null | grep -vE '(sources|javadoc|dev)\.jar$' | head -n 1)
          if [ -z "$JAR_FILE" ]; then
            echo "ERROR: No distributable jar produced"
            echo "=== BUILD LOG TAIL ==="
            tail -100 build.log
            exit 1
          fi
          echo "Found JAR: $JAR_FILE"
          echo "jar_file=$JAR_FILE" >> "$GITHUB_OUTPUT"
          echo "jar_name=$(basename "$JAR_FILE")" >> "$GITHUB_OUTPUT"

      # ----------------------------
      # 13) HARD validation (real mod)
      # ----------------------------
      - name: Validate real mod jar
        env:
          MODID: ${{ steps.modmeta.outputs.modid }}
          JAR: ${{ steps.build.outputs.jar_file }}
        run: |
          set -e
          echo "=== VALIDATING JAR: $JAR ==="
          echo ""
          echo "Jar contents (first 80 lines):"
          unzip -l "$JAR" | head -80
          echo ""

          unzip -l "$JAR" | grep -q "fabric.mod.json" || (echo "ERROR: Missing fabric.mod.json in jar" && exit 1)
          echo "OK: fabric.mod.json found"

          unzip -l "$JAR" | grep -q "\.class$" || (echo "ERROR: No compiled classes in jar" && exit 1)
          echo "OK: Compiled classes found"

          unzip -l "$JAR" | grep -q "build-plan.json" || (echo "ERROR: Missing build-plan.json in jar" && exit 1)
          echo "OK: build-plan.json found"

          echo ""
          echo "=== FEATURE_AUDIT.json INVARIANT CHECK ==="
          if unzip -l "$JAR" | grep -q " FEATURE_AUDIT\.json$"; then
            echo "OK: FEATURE_AUDIT.json found at jar root"
          else
            echo "============================================"
            echo "ERROR: FEATURE_AUDIT.json NOT FOUND at jar root"
            echo "Searching for FEATURE_AUDIT.json anywhere in jar:"
            unzip -l "$JAR" | grep -i "FEATURE_AUDIT" || echo "  (not found anywhere)"
            echo "Expected: src/main/resources/FEATURE_AUDIT.json → jar:FEATURE_AUDIT.json"
            echo "============================================"
            exit 1
          fi

          if unzip -l "$JAR" | grep -q " QA_TEST_PLAN\.md$"; then
            echo "OK: QA_TEST_PLAN.md found at jar root"
          else
            echo "WARNING: QA_TEST_PLAN.md not found at jar root (non-blocking)"
          fi

          unzip -l "$JAR" | grep -q "assets/$MODID/" || (echo "ERROR: Missing assets/$MODID/" && exit 1)
          echo "OK: assets/$MODID/ found"

          unzip -l "$JAR" | grep -q "data/$MODID/" || (echo "ERROR: Missing data/$MODID/" && exit 1)
          echo "OK: data/$MODID/ found"

          echo ""
          echo "=== JAR VALIDATION PASSED ==="

      # ----------------------------
      # 14) EXTRA QUALITY GATE (FIXED)
      #     Replace bogus ">= 5 class files" rule with "Fabric entrypoints exist"
      # ----------------------------
      - name: Validate jar has lang/models/textures + Fabric entrypoints exist
        env:
          MODID: ${{ steps.modmeta.outputs.modid }}
          JAR: ${{ steps.build.outputs.jar_file }}
        run: |
          set -e
          echo "Jar file: $JAR"
          ls -lah "$JAR" || true
          JAR_SIZE=$(stat -c%s "$JAR")
          echo "Jar size bytes: $JAR_SIZE"

          unzip -l "$JAR" | grep -q "assets/$MODID/lang/en_us.json" \
            || (echo "Missing assets/$MODID/lang/en_us.json" && exit 1)

          unzip -l "$JAR" | grep -q "assets/$MODID/models/.*\.json" \
            || (echo "Missing any assets/$MODID/models/*.json" && exit 1)

          unzip -l "$JAR" | grep -q "assets/$MODID/textures/.*\.png" \
            || (echo "Missing any assets/$MODID/textures/*.png" && exit 1)

          # Extract fabric.mod.json from jar and validate entrypoint classes exist
          TMP_DIR=$(mktemp -d)
          unzip -q "$JAR" "fabric.mod.json" -d "$TMP_DIR" || (echo "ERROR: Could not extract fabric.mod.json" && exit 1)

          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');

          const jar = process.env.JAR;
          const tmp = process.env.TMP_DIR;
          const metaPath = path.join(tmp, 'fabric.mod.json');

          const meta = JSON.parse(fs.readFileSync(metaPath, 'utf8'));
          const eps = meta.entrypoints || {};

          const collect = (v) => {
            if (!v) return [];
            if (Array.isArray(v)) return v.flatMap(collect);
            if (typeof v === 'string') return [v];
            if (typeof v === 'object' && v.value) return [String(v.value)];
            return [];
          };

          const main = collect(eps.main);
          const client = collect(eps.client);
          const server = collect(eps.server);

          if (main.length === 0 && client.length === 0 && server.length === 0) {
            console.error('ERROR: fabric.mod.json has no entrypoints (main/client/server).');
            process.exit(1);
          }

          const all = [...new Set([...main, ...client, ...server])];

          const jarList = execSync(`unzip -l "${jar}"`, { encoding: 'utf8' });

          const missing = [];
          for (const fqcn of all) {
            const rel = fqcn.replace(/\./g, '/') + '.class';
            const re = new RegExp(`\\s${rel}$`, 'm');
            if (!re.test(jarList)) missing.push({ fqcn, rel });
          }

          if (missing.length) {
            console.error('ERROR: Missing entrypoint class files in jar:');
            for (const m of missing) console.error(`  - ${m.fqcn} (expected ${m.rel})`);
            process.exit(1);
          }

          console.log('OK: All Fabric entrypoint classes exist in jar:');
          for (const fqcn of all) console.log('  - ' + fqcn);
          NODE

          rm -rf "$TMP_DIR"

          if [ "$JAR_SIZE" -lt 10000 ]; then
            echo "ERROR: Jar is suspiciously small (< 10KB). Likely missing content."
            exit 1
          fi

          echo "OK: Quality gate passed"

      # ----------------------------
      # 15) Validate loot tables have content (warn-only)
      # ----------------------------
      - name: Validate loot tables have content
        env:
          MODID: ${{ steps.modmeta.outputs.modid }}
          JAR: ${{ steps.build.outputs.jar_file }}
        run: |
          set -e
          TEMP_DIR=$(mktemp -d)
          unzip -q "$JAR" -d "$TEMP_DIR"
          LOOT_DIR="$TEMP_DIR/data/$MODID/loot_tables"
          if [ -d "$LOOT_DIR" ]; then
            for loot_file in $(find "$LOOT_DIR" -name "*.json" -type f 2>/dev/null); do
              if ! jq -e '.pools | length > 0' "$loot_file" > /dev/null 2>&1; then
                echo "WARNING: Empty loot table: $loot_file"
              fi
            done
          fi
          rm -rf "$TEMP_DIR"
          echo "OK: Loot table validation complete"

      # ----------------------------
      # 16) Upload artifact (GitHub)
      # ----------------------------
      - name: Upload mod jar (GitHub artifact)
        uses: actions/upload-artifact@v4
        with:
          name: minecraft-mod
          path: ${{ steps.build.outputs.jar_file }}
          retention-days: 7

      # ----------------------------
      # 16b) Upload audit + QA files (GitHub artifact) for debugging
      # ----------------------------
      - name: Upload audit + QA files (GitHub artifact)
        uses: actions/upload-artifact@v4
        with:
          name: audit-and-qa
          path: |
            src/main/resources/FEATURE_AUDIT.json
            src/main/resources/QA_TEST_PLAN.md
          if-no-files-found: warn
          retention-days: 7

      # ----------------------------
      # 17) Upload to R2 (for in-app download)
      # ----------------------------
      - name: Upload mod jar to R2
        id: r2
        env:
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
          R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
          R2_PUBLIC_URL: ${{ secrets.R2_PUBLIC_URL }}
        run: |
          set -e
          pip3 install awscli --quiet
          aws configure set aws_access_key_id "$R2_ACCESS_KEY_ID"
          aws configure set aws_secret_access_key "$R2_SECRET_ACCESS_KEY"
          aws configure set region auto
          JAR_FILE="${{ steps.build.outputs.jar_file }}"
          JAR_NAME="${{ steps.build.outputs.jar_name }}"
          MOD_UUID="${{ steps.buildconfig.outputs.modUuid }}"
          TIMESTAMP=$(date +%s)
          KEY="compiled-mods/${MOD_UUID}/${TIMESTAMP}_${JAR_NAME}"
          echo "Uploading to R2: $KEY"
          aws s3 cp "$JAR_FILE" "s3://${R2_BUCKET_NAME}/${KEY}" \
            --endpoint-url "https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com" \
            --content-type "application/java-archive"
          if [ -n "$R2_PUBLIC_URL" ]; then
            PUBLIC_URL="${R2_PUBLIC_URL}/${KEY}"
          else
            PUBLIC_URL="https://${R2_BUCKET_NAME}.r2.dev/${KEY}"
          fi
          echo "storage_path=$KEY" >> "$GITHUB_OUTPUT"
          echo "compiled_jar_url=$PUBLIC_URL" >> "$GITHUB_OUTPUT"
          echo "OK: Uploaded to $PUBLIC_URL"

      # ----------------------------
      # 17b) Wait until R2 URL is actually reachable (prevents UI/email race)
      # ----------------------------
      - name: Verify R2 URL is reachable (retry)
        env:
          URL: ${{ steps.r2.outputs.compiled_jar_url }}
        run: |
          set -e
          echo "Checking accessibility: $URL"
          for i in 1 2 3 4 5 6 7 8 9 10; do
            if curl -I -sS --fail "$URL" >/dev/null; then
              echo "OK: R2 URL reachable"
              exit 0
            fi
            echo "Not reachable yet (attempt $i/10) — sleeping 3s..."
            sleep 3
          done
          echo "ERROR: R2 URL still not reachable after retries"
          exit 1

      # ----------------------------
      # 18) Webhook success (STRICT + logs)
      # ----------------------------
      - name: Notify webhook (success)
        if: success()
        run: |
          set -e
          WEBHOOK_URL="${{ steps.buildconfig.outputs.webhookUrl }}"
          WEBHOOK_SECRET="${{ steps.buildconfig.outputs.webhookSecret }}"
          MOD_UUID="${{ steps.buildconfig.outputs.modUuid }}"
          STORAGE_PATH="${{ steps.r2.outputs.storage_path }}"
          COMPILED_URL="${{ steps.r2.outputs.compiled_jar_url }}"
          SHA="${{ github.sha }}"
          RUN_ID="${{ github.run_id }}"
          PAYLOAD=$(jq -n \
            --arg modId "$MOD_UUID" \
            --arg status "completed" \
            --arg storagePath "$STORAGE_PATH" \
            --arg storage_path "$STORAGE_PATH" \
            --arg compiledJarUrl "$COMPILED_URL" \
            --arg compiled_jar_url "$COMPILED_URL" \
            --arg gitSha "$SHA" \
            --arg runId "$RUN_ID" \
            '{modId:$modId,status:$status,storagePath:$storagePath,storage_path:$storage_path,compiledJarUrl:$compiledJarUrl,compiled_jar_url:$compiled_jar_url,gitSha:$gitSha,runId:$runId}')
          RESPONSE=$(curl --fail-with-body -sS \
            -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "x-webhook-secret: $WEBHOOK_SECRET" \
            -d "$PAYLOAD" \
            -w "\n%{http_code}")
          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | head -n -1)
          echo "Response code: $HTTP_CODE"
          echo "Response body: $BODY"
          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            echo "ERROR: Webhook returned non-2xx status"
            exit 1
          fi

      # ----------------------------
      # 19) Webhook failure (STRICT + logs)
      # ----------------------------
      - name: Notify webhook (failure)
        if: failure()
        run: |
          set -e
          WEBHOOK_URL="${{ steps.buildconfig.outputs.webhookUrl }}"
          WEBHOOK_SECRET="${{ steps.buildconfig.outputs.webhookSecret }}"
          MOD_UUID="${{ steps.buildconfig.outputs.modUuid }}"
          if [ -z "$WEBHOOK_URL" ]; then
            echo "No webhookUrl available; skipping webhook."
            exit 0
          fi
          ERROR_MSG="Build failed"
          if [ -f "build.log" ]; then
            ERROR_MSG=$(grep -iE "error:|FAILURE:|Exception" build.log | head -8 | tr '\n' ' ' | cut -c1-800 || echo "Build failed - see logs")
          fi
          PAYLOAD=$(jq -n \
            --arg modId "$MOD_UUID" \
            --arg status "failed" \
            --arg error "$ERROR_MSG" \
            --argjson storage_path null \
            --argjson storagePath null \
            '{modId:$modId,status:$status,error:$error,storage_path:$storage_path,storagePath:$storagePath}')
          curl --fail-with-body -sS \
            -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "x-webhook-secret: $WEBHOOK_SECRET" \
            -d "$PAYLOAD" || echo "Webhook notification failed (non-blocking)"

      # ----------------------------
      # 20) Upload build log on failure
      # ----------------------------
      - name: Upload build log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-log
          path: build.log
          retention-days: 3
