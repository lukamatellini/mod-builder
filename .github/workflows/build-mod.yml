name: Build Minecraft Mod

on:
  workflow_dispatch:
    inputs:
      mod_id:
        description: "Mod UUID from database"
        required: true
      mod_name:
        description: "Human-readable mod name"
        required: true
      loader:
        description: "Mod loader (fabric or forge)"
        required: true
        default: "fabric"
      mc_version:
        description: "Minecraft version (must be 1.21.x)"
        required: true
        default: "1.21.11"
      mod_files:
        description: "Base64-encoded JSON of mod files"
        required: true
      webhook_url:
        description: "URL to call when build completes"
        required: true
      webhook_secret:
        description: "Secret for webhook authentication"
        required: true

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Guardrails (Fabric + MC 1.21.x only)
        run: |
          set -e
          if [ "${{ github.event.inputs.loader }}" != "fabric" ]; then
            echo "ERROR: This workflow supports Fabric only."
            exit 1
          fi
          MC="${{ github.event.inputs.mc_version }}"
          case "$MC" in
            1.21.*) echo "OK: MC version allowed: $MC" ;;
            *) echo "ERROR: Unsupported mc_version: $MC (allow only 1.21.x)"; exit 1 ;;
          esac

      - name: Set up Node.js (for unpacking + validation)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Create mod project from mod_files
        run: |
          set -e
          mkdir -p mod-project
          cd mod-project

          echo '${{ github.event.inputs.mod_files }}' | base64 -d > files.json

          node << 'EOF'
          const fs = require('fs');
          const path = require('path');

          const files = JSON.parse(fs.readFileSync('files.json', 'utf8'));
          for (const [filePath, content] of Object.entries(files)) {
            const fullPath = path.join('.', filePath);
            fs.mkdirSync(path.dirname(fullPath), { recursive: true });
            fs.writeFileSync(fullPath, content);
          }
          console.log("Unpacked files:", Object.keys(files).length);
          EOF

      - name: Read modid from fabric.mod.json + check MC range declaration
        id: modmeta
        working-directory: mod-project
        run: |
          set -e
          node << 'EOF'
          const fs = require('fs');
          const p = 'src/main/resources/fabric.mod.json';
          if (!fs.existsSync(p)) throw new Error(`Missing ${p}`);
          const meta = JSON.parse(fs.readFileSync(p,'utf8'));

          if (!meta.id) throw new Error("fabric.mod.json missing 'id'");
          if (!meta.depends || !meta.depends.minecraft) throw new Error("fabric.mod.json missing depends.minecraft");

          const mc = String(meta.depends.minecraft).replace(/\s+/g,'');
          if (!(mc.includes(">=1.21") && mc.includes("<1.22"))) {
            throw new Error(`depends.minecraft must include ">=1.21 <1.22". Found: ${meta.depends.minecraft}`);
          }

          console.log(meta.id);
          EOF > /tmp/modid.txt

          echo "modid=$(cat /tmp/modid.txt)" >> $GITHUB_OUTPUT
          echo "Detected modid: $(cat /tmp/modid.txt)"

      - name: Set up Java 21 (Minecraft 1.21.x)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "21"

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3
        with:
          gradle-version: "8.4"

      - name: Build with Gradle (prefer wrapper, build remapped jar)
        id: build
        working-directory: mod-project
        run: |
          set -e

          if [ -f "./gradlew" ]; then
            chmod +x ./gradlew
            ./gradlew clean build remapJar --no-daemon --info
          else
            gradle clean build remapJar --no-daemon --info
          fi

          echo "==== build/libs contents ===="
          ls -lah build/libs || true

          # Prefer Loom's remapped jar if it exists
          REMAP_JAR=$(ls -1 build/libs/*-all.jar 2>/dev/null || true)
          if [ -z "$REMAP_JAR" ]; then
            # Many Loom setups output: *-fabric.jar or just the main jar after remap
            REMAP_JAR=$(ls -1S build/libs/*.jar \
              | grep -vE '(sources|javadoc|dev)\.jar$' \
              | head -n 1)
          fi

          if [ -z "$REMAP_JAR" ]; then
            echo "ERROR: No distributable jar found in build/libs"
            exit 1
          fi

          echo "jar_file=$REMAP_JAR" >> $GITHUB_OUTPUT
          echo "jar_name=$(basename $REMAP_JAR)" >> $GITHUB_OUTPUT
          echo "Built JAR: $REMAP_JAR"

      - name: Validate jar (base + build-plan single source of truth)
        working-directory: mod-project
        run: |
          set -e
          JAR="${{ steps.build.outputs.jar_file }}"
          MODID="${{ steps.modmeta.outputs.modid }}"

          echo "Validating jar: $JAR"

          # Base: must be a real Fabric mod jar
          unzip -l "$JAR" | grep -q "fabric.mod.json" || (echo "ERROR: Missing fabric.mod.json inside jar" && exit 1)
          unzip -l "$JAR" | grep -qE "\.class$" || (echo "ERROR: No compiled .class files found inside jar" && exit 1)

          # NEW: build-plan.json is mandatory under your new architecture
          unzip -l "$JAR" | grep -q "build-plan.json" || (echo "ERROR: Missing build-plan.json inside jar" && exit 1)

          # Extract build-plan.json for plan-driven validation
          rm -f /tmp/build-plan.json
          unzip -p "$JAR" build-plan.json > /tmp/build-plan.json || (echo "ERROR: Could not read build-plan.json" && exit 1)

          # Plan sanity + module expectations (adjust keys here if your build-plan fields differ)
          node << 'EOF'
          const fs = require('fs');

          const plan = JSON.parse(fs.readFileSync('/tmp/build-plan.json','utf8'));
          const range = String(plan.minecraftRange || '');

          if (!(range.includes(">=1.21") && range.includes("<1.22"))) {
            throw new Error(`build-plan.json minecraftRange must include ">=1.21 <1.22". Found: ${range}`);
          }

          const enabled = new Set(plan.enabledModules || []);
          const expected = plan.expectedContent || {};

          function expectMin(moduleName, key, min = 1) {
            if (enabled.has(moduleName)) {
              const v = Number(expected[key] ?? 0);
              if (!Number.isFinite(v) || v < min) {
                throw new Error(`Module "${moduleName}" enabled but expectedContent.${key} < ${min} (got ${expected[key]})`);
              }
            }
          }

          // These keys MUST match your build-plan.json schema:
          expectMin("quests", "quests", 1);
          expectMin("dialogue", "dialogueNodes", 1);
          expectMin("items", "items", 1);
          expectMin("structures", "structures", 1);
          expectMin("biomes", "biomes", 1);
          expectMin("dimensions", "dimensions", 1);

          console.log("Build plan sanity checks passed.");
          EOF

          # File presence checks driven by build plan modules
          node << 'EOF'
          const fs = require('fs');
          const { execSync } = require('child_process');

          const jar = process.env.JAR_PATH;
          const modid = process.env.MODID;
          const plan = JSON.parse(fs.readFileSync('/tmp/build-plan.json','utf8'));
          const enabled = new Set(plan.enabledModules || []);

          function jarHas(pattern) {
            const out = execSync(`unzip -l "${jar}"`).toString('utf8');
            return out.includes(pattern);
          }

          function requireAnyRegex(regex, err) {
            const out = execSync(`unzip -l "${jar}"`).toString('utf8');
            if (!new RegExp(regex).test(out)) throw new Error(err);
          }

          if (enabled.has("quests")) {
            requireAnyRegex(`data/${modid}/quests/.+\\.json$`, `Missing quest jsons in data/${modid}/quests/`);
          }
          if (enabled.has("dialogue")) {
            requireAnyRegex(`data/${modid}/dialogue/.+\\.json$`, `Missing dialogue jsons in data/${modid}/dialogue/`);
          }
          if (enabled.has("structures") || enabled.has("biomes") || enabled.has("dimensions")) {
            // World content should at least ship some worldgen definitions OR templates used by your command-based placement.
            // If your system uses a different folder, update this.
            if (!jarHas(`data/${modid}/worldgen/`)) {
              throw new Error(`World-content module enabled but missing data/${modid}/worldgen/ (update this check if you use another path)`);
            }
            requireAnyRegex(`data/${modid}/worldgen/.+\\.json$`, `Worldgen folder exists but contains no json files`);
          }
          if (enabled.has("items")) {
            // Basic assets sanity (textures/models/lang). If your build-plan guarantees these, enforce them.
            if (!jarHas(`assets/${modid}/lang/`)) throw new Error(`Items enabled but missing assets/${modid}/lang/`);
            if (!jarHas(`assets/${modid}/textures/`)) throw new Error(`Items enabled but missing assets/${modid}/textures/`);
            if (!jarHas(`assets/${modid}/models/`)) throw new Error(`Items enabled but missing assets/${modid}/models/`);
          }

          console.log("Plan-driven jar content checks passed.");
          EOF
        env:
          JAR_PATH: ${{ steps.build.outputs.jar_file }}
          MODID: ${{ steps.modmeta.outputs.modid }}

      - name: Upload to R2
        id: upload
        env:
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
          R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
          R2_PUBLIC_URL: ${{ secrets.R2_PUBLIC_URL }}
        run: |
          set -e
          cd mod-project
          JAR_FILE="${{ steps.build.outputs.jar_file }}"
          JAR_NAME="${{ steps.build.outputs.jar_name }}"
          MOD_ID="${{ github.event.inputs.mod_id }}"

          pip install awscli

          aws configure set aws_access_key_id "$R2_ACCESS_KEY_ID"
          aws configure set aws_secret_access_key "$R2_SECRET_ACCESS_KEY"
          aws configure set region auto

          TIMESTAMP=$(date +%s)
          KEY="compiled-mods/${MOD_ID}/${TIMESTAMP}_${JAR_NAME}"

          aws s3 cp "$JAR_FILE" "s3://${R2_BUCKET_NAME}/${KEY}" \
            --endpoint-url "https://${R2_ACCOUNT_ID}.r2.cloudflarestorage.com" \
            --content-type "application/java-archive"

          if [ -n "$R2_PUBLIC_URL" ]; then
            PUBLIC_URL="${R2_PUBLIC_URL}/${KEY}"
          else
            PUBLIC_URL="https://${R2_BUCKET_NAME}.r2.dev/${KEY}"
          fi

          echo "jar_url=$PUBLIC_URL" >> $GITHUB_OUTPUT
          echo "Uploaded to: $PUBLIC_URL"

      - name: Notify webhook on success
        if: success()
        env:
          WEBHOOK_URL: ${{ github.event.inputs.webhook_url }}
          WEBHOOK_SECRET: ${{ github.event.inputs.webhook_secret }}
        run: |
          set -e
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "x-webhook-secret: $WEBHOOK_SECRET" \
            -d "{\"modId\":\"${{ github.event.inputs.mod_id }}\",\"status\":\"success\",\"compiledJarUrl\":\"${{ steps.upload.outputs.jar_url }}\"}"

      - name: Notify webhook on failure
        if: failure()
        env:
          WEBHOOK_URL: ${{ github.event.inputs.webhook_url }}
          WEBHOOK_SECRET: ${{ github.event.inputs.webhook_secret }}
        run: |
          set -e
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "x-webhook-secret: $WEBHOOK_SECRET" \
            -d "{\"modId\":\"${{ github.event.inputs.mod_id }}\",\"status\":\"failed\",\"error\":\"Build failed - check GitHub Actions logs\"}"





